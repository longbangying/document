# redis

###如何保证缓存与数据库双写时的数据一致性？


###缓存雪崩和缓存穿透问题的解决方案
+ 缓存雪崩
- -  简介：缓存同一时间大面积的失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉
- - 解决办法：
```sql
事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略
事中：本地ehcache缓存+hystrix限流&降级，避免数据库崩掉
事后：利用redis持久化机制保存的数据尽快恢复缓存
```
+ 缓存穿透
- - 简介：一般是黑客故意去请求缓存中不存在的数据，导致请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉；
- - 解决方法：最常见的方法是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，
```sql
1.采用布隆过滤器，将所有可能存在的数据都哈希到一个足够大的bitmap中，一个不存在的数据可定会被拦截掉，从而避免了对底层存储系统的查询压力；
2.如果查询结果为空(不管是数据不存在还是系统故障)，都将结果缓存到redis,缓存过期时间尽量设置短一些，不超过5分钟；
```
###redis事务
- 概念 ： redis事务本质上是一组命令的集合，支持一次执行多个命令，事务中的所有命令都会被序列化，在事务执行过程，会按照顺序串行执行队列中的命令，其它客户端提交的命令请求不会插入到事务执行序列中。
- 没有事务隔离：批量操作在执行exec命令之前会被缓存在执行队列中，并不会被执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。
- 不保证原子性：redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚，事务中任意命令执行失败，其余的命令仍会被执行；
- redis事务的三个阶段：
```sql
开始事务
命令入队
执行事务
```
- redis事务相关命令
```sql
watch key    //监视一个会多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断(事务失败)
multi        //标记一个事务块的开始(queued)
exec         //执行事务块的命令(一旦执行exec后，之前加的监控锁都会被取消掉)
discard      //取消事务，放弃事务块中的所有命令，应在exec之前
unwatch      //取消watch 对所有key的监控
```
- 事务块中的命令如果某条命令是错误的(redis不支持的命令)会导致事务失败且所有的命令都不会被执行，除此之外的错误，事务都会被执行且其它命令的不会回滚；
###redis持久化机制
- 快照(snapshotting,RDB)  redis 默认的持久化方式
	redis.conf 默认配置如下：
	```sql
save 900 1   //在900秒(15分钟)里，如果至少有一个key发生变化，redis就会自动触发BGSAVE命令创建快照；
save 300 10  //在300秒(5分钟)里，如果至少10个key发生变化，redis就会自动触发BGSAVE命令创建快照；
save 60 10000  //在60秒(1分钟)里,如果至少10000个key发生变化，redis就会自动触发BGSAVE命令创建快照；
```
- 只追加文件(append-only file,AOF) 
	相较于快照方式，AOF持久化的实时性更好，默认下redis 没有开启，可以通过以下配置开启
	`appendonly yes   //开启AOF`
	开启AOF后，对于命一条会改变数据的命令，redis都会将该命令写入硬盘的AOF文件中，保存位置和数据文件(RDB)相同，可以通过 
	`dir   具体路径配置`
	同步时机：
	```sql
appendsync always   //每次有数据修改发生时都会写入AOF文件，这样会严重降低redis的速度；
appendsync everysec //每秒同步一次，将写命令同步到硬盘，推荐此种方式
appendsync no       //让操作系统决定何时合同
```


###redis的内存淘汰机制(淘汰策略)
- volatile-lru : 从已设置过期时间的数据集(service.db[i].expires)中挑选最少使用的数据淘汰；
- volatile-ttl : 从已设置过期时间的数据集(service.db[i].expires)中挑选将要过期的数据淘汰；
- volatile-random : 从已设置过期时间的数据集(service.db[i].expires)中任意选择数据淘汰；
- allkeys-lru ： 当内存不足以容纳新写入的数据时，在键空间中，移除最近最少使用的key(常用);
- allkeys-random : 从数据集(service.db[i].dict)中任意选择数据淘汰；
- no-eviction : 禁止驱逐数据，也就是说内存不足时拒绝写入数据，直接报错；
#### 触发条件
	当redis现有的数据大小已经达到在redis.conf 中配置的 maxmemory 的值，就会触发redis的内存淘汰策略，默认是 no-eviction ；


